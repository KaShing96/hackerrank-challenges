2020.05.05: 
    Unaware of what changes I did, but a line-by-line investigation into the timing of the code, as well as likely shortening the time allocated for the traceback approach 2-row matrix generation, allowed the verification tests to complete in the allocated time.

    Success!

2020.05.04: 
    One suggestion from the discussion page is to keep only the history from the previous row. We attempt this. Function still times out. 

    Attempting to do this with a fixed size array of 2 rows and len(s2) columns also times out. 

    Requires further consultation of HackerRank page. 

2020.05.03: 
    We attempt to reduce the runtime of the loop by reducing the checking of ix = 0 and jx = 0 by padding the topmost and leftmost row and column respectively with 0s. Uncertain if it will reduce runtime. This failed. 

    Attempting to use a matrix is likely too large. Instead, we attempt to use a dictionary, where the keys are the row-column pairs and the value is the number. Still does not work. 

    Consult the HackerRank discussion page. 

2020.05.02: Inspiration drawn from 'Traceback Approach' of https://www.wikiwand.com/en/Longest_common_subsequence_problem without viewing worked example. While the code successfully executed on the bottlenecked test case, another test case - Test Case 5 - is the new bottleneck. 

2020.04.29: Checking it character by character by isolating the first character in s1 and then building potential matches in s1 and s2 fails. We cannot cover the variable space of possible substrings generated by character removal. 

2020.04.28: Attempting to solve it by extracting regexes from s1 with anonymised characters (represented by the period, '.') and checking it for regex matches in s2 takes too long to solve for the verification case. An alternative needs to be found.

2020.04.27: It is becoming apparent that any loop through every possible string is too computationally-intensive for the verification case. Thus, we can attempt to, instead of reducing BOTH the strings and finding an equally, opt to explore reducing only ONE of the strings and finding if any of its substrings are within string 2.

2020.04.21: There seems to be something occupying the second nested for loop. Assigning t to lists[lk] seems to take forever, or freezes the command prompt utterly as 'funcTimeout' doesn't seem to be stopping it. The curiosity here is that individually, accessing lists[lk], temp, and assigning values to lists[lk] seems to work fine. 

2020.04.20: Rather than redoing substrings(), we redo the commonChild() function. We need to pre-check that s1 and s2 are of the same length; if they are not, we set l1 and l2 to lists containing strings of length equal to the shorter of the two strings, with these lists obtained via remove().

2020.04.19: Redo substrings() function.